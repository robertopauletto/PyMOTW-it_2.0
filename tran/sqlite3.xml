<?xml version="1.0" encoding="Latin-1"?>
<categoria>persistenza dati </categoria><!-- # tag <descrizione> contiene le voci per la tabella di riepilogo iniziale -->
<!-- # tag <titolo_1> titolo principale -->
<!-- tag <testo_normale> contiene il testo normale dell'articolo -->
<!-- tag <titolo_2> contiene il testo per l'intestazione di un paragrafo -->
<!-- tag <py_code> contiene il testo che rappresenta delle istruzioni python -->
<!-- tag <py_output> contiene il testo che rappresenta l'output di uno script python -->
<!-- tag <vedi_anche> contiene il testo che rappresentano i riferimenti esterni -->
<!-- tag <lista> ogni riga all'interno del tag rappresenta una riga di una lista non ordinata'-->
<documento_tradotto>
<titolo_1>
sqlite3 - Database Relazionale Incorporabile
</titolo_1>
<descrizione>
Implementa un database relazionale incorporabile con supporto SQL
2.5 e superiore
</descrizione>
<testo_normale>
Il modulo <strong>sqlite3</strong> fornisce una interfaccia compatibile DB-API 2.0 al database relazionale <a href='http://www.sqlite.org/'>SQLite</a>. SQLite &egrave; un database <em>in-process</em> concepito per essere incorporato in applicazioni, invece di usare un programma server di database separato tipo MySQL, PostgreSQL oppure Oracle. SQLite &egrave; veloce, rigorosamente testato, flessibile, rendendolo candidato per il prototipizzazione e lo sviluppo di produzione per certe applicazioni.
</testo_normale>
<titolo_2>
Creare un Database
</titolo_2>
<testo_normale>
Un database SQLite viene conservato in un singolo file nel filesystem. La libreria gestisce l'accesso al file, incluso il bloccaggio per prevenire corruzione di dati quando viene usato in scrittura da utenti multipli. Il database viene creato la prima volta che si accede al file, ma l'applicazione &egrave; responsabile per la gestione delle definizioni della tabella, note come <em>schema</em>. all'interno del database.
</testo_normale>
<testo_normale>
In questo esempio si cerca il file database prima di aprirlo con ${sbk}connect()${ebk} in modo da sapere quando creare lo <em>schema</em> per i nuovi database.
</testo_normale>
<py_code>
import os
import sqlite3

db_filename = 'todo.db'

db_is_new = not os.path.exists(db_filename)

conn = sqlite3.connect(db_filename)

if db_is_new:
    print 'Occorre creare lo schema'
else:
    print 'Il database esiste, si suppone che esista anche lo schema.'

conn.close()
</py_code>
<testo_normale>
Quando si esegue lo script per due volte si dimostra che esso crea il file vuoto, se non esiste.
</testo_normale>
<py_output>
$ ls *.db
ls: impossibile accedere a *.db: File o directory non esistente

$ python sqlite3_createdb.py 
Occorre creare lo schema

$ ls *.db
todo.db

$ python sqlite3_createdb.py 
Il database esiste, si suppone che esista anche lo schema.
</py_output>
<testo_normale>
Il passo successivo dopo la creazione del nuovo file di database, &egrave; quello di creare lo <em>schema</em> per definire le tabelle all'interno del database. Gli esempi che seguono in questa sezione usano tutti lo stesso <em>schema</em> di database con delle tabelle per la gestione di compiti.<br />Le tabelle sono:
</testo_normale>
<testo_normale>
<strong>progetto</strong>
</testo_normale>
<tabella_semplice>
Colonna;Tipo;Descrizione
nome;testo;Nome del progetto
descrizione;testo;Descrizione dettagliata del progetto
scadenza;data;Data di scadenza per l'intero progetto
</tabella_semplice>
<testo_normale>

</testo_normale>
<testo_normale>
<strong>compito</strong>
</testo_normale>
<tabella_semplice>
Colonna;Tipo;Descrizione
id;numerico;Identifcativo univoco del compito
priorita;intero;Priorità numerica numero più basso = priorità maggiore
dettagli;testo;Descrizione completa del compito
stato;testo;Stato del compito (uno tra 'nuovo' - 'da finire' - 'finito' - 'eliminato')
scadenza;data;Data di scadenza per questo compito
completato_il;data;Quando il compito viene completato
progetto;testo;il nome del progetto per questo compito.
</tabella_semplice>
<testo_normale>

</testo_normale>
<testo_normale>

</testo_normale>
<testo_normale>
Le istruzioni in <em>data definition language</em> (DDL) per creare le tabelle sono:
</testo_normale>
<sql_code>
-- Schema per gli esempi dell'applicazione to-do.

-- I progetti sono le attivita'; di alto livello composte da compiti
create table progetto (
    nome        text primary key,
    descrizione text,
    scadenza    date
);

-- I compiti sono le attivita'; che possono essere svolte per completare un progetto

create table compito (
    id            integer primary key autoincrement not null,
    priorita      integer default 1,
    dettagli      text,
    stato         text,
    scadenza      date,
    completato_il date,
    progetto      text not null references project(name)
);
</sql_code>
<testo_normale>
Il metodo ${sbk}executescript()${ebk} della <strong>connessione</strong> pu&ograve; essere usato per eseguire le istruzioni DDL per creare lo schema.
</testo_normale>
<py_code>
import os
import sqlite3

db_filename = 'todo.db'
schema_filename = 'todo_schema.sql'

db_is_new = not os.path.exists(db_filename)

with sqlite3.connect(db_filename) as conn:
    if db_is_new:
        print 'Creazione dello schema'
        with open(schema_filename, 'rt') as f:
            schema = f.read()
        conn.executescript(schema)

        print 'Inserimento dei dati di partenza'
        
        conn.execute("""
        insert into progetto (nome, descrizione, scadenza)
        values ('pymotw-it', 'Il modulo Python della Settimana', '2010-11-01')
        """)
        
        conn.execute("""
        insert into compito (dettagli, stato, scadenza, progetto)
        values ('descrivere select', 'fatto', '2010-10-03', 'pymotw-it')
        """)
        
        conn.execute("""
        insert into compito (dettagli, stato, scadenza, progetto)
        values ('descrivere random', 'in attesa', '2010-10-10', 'pymotw-it')
        """)
        
        conn.execute("""
        insert into compito (dettagli, stato, scadenza, progetto)
        values ('descrivere sqlite3', 'attivo', '2010-10-17', 'pymotw-it')
        """)
    else:
        print 'Il database esiste, si suppone che esista anche lo schema.'

</py_code>
<testo_normale>
Dopo che sono state create le tabelle, alcune istruzioni ${sev}insert${eev} creano un progetto di esempio ed i compiti relativi. Il programma da riga di comando <strong>sqlite3</strong> pu&ograve; essere usato per esaminare il contenuto del database.
</testo_normale>
<py_output>
$ python sqlite3_create_schema.py 

Creazione dello schema
Inserimento dei dati di partenza

$ sqlite3 todo.db 'select * from compito'

1|1|descrivere select|fatto|2010-10-03||pymotw-it
2|1|descrivere random|in attesa|2010-10-10||pymotw-it
3|1|descrivere sqlite3|attivo|2010-10-17||pymotw-it
</py_output>
<titolo_2>
Recuperare i Dati
</titolo_2>
<testo_normale>
Per recuperare i valori salvati nella tabella <strong>compito</strong> all'interno di un programma Python, si crea un cursore ${sbk}Cursor${ebk} da una connessione del database usando il metodo ${sbk}cursor()${ebk}. Un cursore fornisce una vista consistente dei dati, e costituisce il mezzo principale per interagire con un sistema di database transazionale come SQLite.
</testo_normale>
<py_code>
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute("""
    select id, priorita, dettagli, stato, scadenza from compito where progetto = 'pymotw-it'
    """)

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-20s [%-8s] (%s)' % (task_id, priority, details, status, deadline)
</py_code>
<testo_normale>
L'interrogazione si svolge in due passi. Per prima cosa si esegue l'interrogazione con il metodo del cursore ${sbk}execute()${ebk} per informare il motore del database di quali dati deve raccogliere. Quindi si usa ${sbk}fetchall()${ebk} per recuperare i risultati. Il valore restituito &egrave; una sequenza di tuple che contengono i valori per le colonne indicate nella clausola ${sev}select${eev} dell'interrogazione.
</testo_normale>
<py_output>
$ python sqlite3_select_tasks.py 

 1 {1} descrivere select    [fatto    ] (2010-10-03)
 2 {1} descrivere random    [in attesa] (2010-10-10)
 3 {1} descrivere sqlite3   [attivo   ] (2010-10-17)
</py_output>
<testo_normale>
I risultati possono essere recuperati uno alla volta con ${sbk}fetchone()${ebk}, oppure in blocchi di dimensione finita con ${sbk}fetchmany()${ebk}.
</testo_normale>
<py_code>
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute("""
    select nome, descrizione, scadenza from progetto where nome = 'pymotw-it'
    """)
    name, description, deadline = cursor.fetchone()

    print 'Dettagli del progetto per %s (%s) scadenza %s' % (description, name, deadline)

    cursor.execute("""
    select id, priorita, dettagli, stato, scadenza from compito
    where progetto = 'pymotw-it' order by scadenza
    """)

    print '\nProssimi 5 compiti:'

    for row in cursor.fetchmany(5):
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-25s [%-8s] (%s)' % (task_id, priority, details, status, deadline)
</py_code>
<testo_normale>
Il valore passato a ${sbk}fetchmany()${ebk} &egrave; il numero massimo di elementi da restituire. Se gli elementi disponibili sono meno, la sequenza restituita sar&agrave; pi&ugrave; piccola rispetto al valore massimo passato.
</testo_normale>
<py_output>
$ python sqlite3_select_variations.py 

Dettagli del progetto per Il modulo Python della Settimana (pymotw-it) scadenza 2010-11-01

Prossimi 5 compiti:
 1 {1} descrivere select         [fatto    ] (2010-10-03)
 2 {1} descrivere random         [in attesa] (2010-10-10)
 3 {1} descrivere sqlite3        [attivo   ] (2010-10-17)
</py_output>
<titolo_2>
Interrogare i Metadati
</titolo_2>
<testo_normale>
Le specifiche <a href='http://www.python.org/dev/peps/pep-0249/'>DB-API 2.0</a>  dicono che dopo la chiamata di ${sbk}execute()${ebk}, il cursore ${sbk}Cursor${ebk} dovrebbe impostare l'attributo <em>description</em> in modo che contenga delle informazioni circa i dati che verranno restituiti dai metodi di recupero. Le specifiche API dicono che il valore di <em>description</em> deve essere una sequenza di tuple che contengono il nome della colonna, il tipo, la dimensione di visualizzazione, la dimensione interna, la precisione, la scala ed un flag che dice se i valori null debbano essere accettati.
</testo_normale>
<py_code>
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute("""
    select * from compito where progetto = 'pymotw-it'
    """)

    print 'La tabella Compito ha queste colonne:'
    for colinfo in cursor.description:
        print colinfo
</py_code>
<testo_normale>
Visto che <strong>sqlite3</strong> non impone costrizioni di tipo o dimensione sui dati inseriti nel database, viene inserito solo il valore del nome della colonna.
</testo_normale>
<py_output>
$ python sqlite3_cursor_description.py 

La tabella Compito ha queste colonne:
('id', None, None, None, None, None, None)
('priorita', None, None, None, None, None, None)
('dettagli', None, None, None, None, None, None)
('stato', None, None, None, None, None, None)
('scadenza', None, None, None, None, None, None)
('completato_il', None, None, None, None, None, None)
('progetto', None, None, None, None, None, None)
</py_output>
<titolo_3>
Oggetti Riga
</titolo_3>
<testo_normale>
Nella modalit&agrave; predefinita, i valori restituiti dai metodi di recupero sotto forma di "righe" dal database sono tuple. Il chiamante &egrave; responsabile della conoscenza dell'ordine delle colonne nell'interrogazione e dell'estrazione dei valori individuali dalla tupla. Quando il numero di valori in una interrogazione cresce, oppure il codice che lavora con i dati &egrave; sparso in una libreria, in genere &egrave; pi&ugrave; facile lavorare con un oggetto ed accedere i valori di colonna usando il nome delle colonne stesse, visto che in questo modo il numero e l'ordine degli elementi della tupla possono cambiare nel corso del tempo mano a mano che l'interrogazione viene modificata, ed il codice che dipende dai risultati dell'interrogazione &egrave; meno prono agli errori.
</testo_normale>
<testo_normale>
Gli oggetti ${sbk}Connection${ebk} hanno una propriet&agrave; ${sev}row_factory${eev} che consente al codice chiamante di controllare il tipo di oggetto creato per rappresentare ogni riga nel risultato dell'interrogazione impostata. <strong>sqlite3</strong> comprende anche una classe ${sbk}Row${ebk} che &egrave; intesa per l'uso come row factory. Le istanze di ${sbk}Row${ebk} possono essere indirizzate tramite l'indice di colonna ed il nome.
</testo_normale>
<py_code>
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    # Modifica row factory per usare Row
    conn.row_factory = sqlite3.Row
    
    cursor = conn.cursor()

    cursor.execute("""
    select nome, descrizione, scadenza from progetto where nome = 'pymotw-it'
    """)
    name, description, deadline = cursor.fetchone()

    print 'Dettagli del progetto %s (%s) scadenza %s' % (description, name, deadline)

    cursor.execute("""
    select id, priorita, stato, scadenza, dettagli from compito
    where progetto = 'pymotw-it' order by scadenza
    """)

    print '\nProssimi 5 compiti:'

    for row in cursor.fetchmany(5):
        print '%2d {%d} %-25s [%-8s] (%s)' % (
            row['id'], row['priorita'], row['dettagli'], row['stato'], row['scadenza'],
            )
</py_code>
<testo_normale>
Questa versione dell'esempio ${sev}sqlite3_select_variations.py${eev} &egrave; stato riscritto usando istanze di ${sbk}Row${ebk} in luogo delle tuple. La riga progetto viene comunque stampata indirizzando i valori di colonna in base alla posizione, ma l'istruzione ${sbk}print${ebk} per i compiti usa invece la ricerca tramite parola chiave, in modo che non importi se l'ordine delle colonne nell'interrogazione &egrave; stato cambiato.
</testo_normale>
<py_output>
$ python sqlite3_row_factory.py 

Dettagli del progetto Il modulo Python della Settimana (pymotw-it) scadenza 2010-11-01

Prossimi 5 compiti:
 1 {1} descrivere select         [fatto    ] (2010-10-03)
 2 {1} descrivere random         [in attesa] (2010-10-10)
 3 {1} descrivere sqlite3        [attivo   ] (2010-10-17)
</py_output>
<titolo_2>
Usare Variabili con le Interrogazioni
</titolo_2>
<testo_normale>
L'uso di interrogazioni definite come stringhe letterali incorporate nel programma non consente mutamenti. Ad esempio, quando viene aggiunto un altro progetto al database l'interrogazione per mostrare i primi cinque compiti dovrebbe essere aggiornata in modo che possa funzionare per entrambi i progetti. Un modo per aggiungere maggiore flessibilit&agrave; &egrave; di costruire l'istruzione SQL con l'interrogazione desiderata combinando i valori in Python. Comunque, costruire in questo modo una stringa di interrogazione &egrave; pericoloso, e dovrebbe essere evitato. Sbagliare la costruzione di una sequenza di escape per i caratteri speciali nelle parti variabili dell'interrogazione pu&ograve; risultare in un errore di analisi in SQL, o peggio in una classe di vulnerabilit&agrave; alla sicurezza nota come <a href='http://it.wikipedia.org/wiki/SQL_injection'>attacchi SQL-injection</a>.
</testo_normale>
<testo_normale>
Il modo giusto per usare valori dinamici con le interrogazioni &egrave; tramite <em>variabili ospiti</em> passate ad ${sbk}execute()${ebk} assieme all'istruzione SQL. Un valore segnaposto in SQL viene sostiuito dal valore nella variabile ospite quando viene eseguita l'istruzione. L'uso di variabili ospite al posto dell'inserimento di valori arbitrari nell'istruzione SQL prima che sia analizzata evita gli attacchi <em>SQL-injection</em> perch&egrave; non esiste possibilit&agrave; che valori non affidabili possano influenzare il modo in cui l'istruzione SQL viene analizzata. SQLite supporta due forme di interrogazioni con segnaposto, posizionali e nominali.
</testo_normale>
<titolo_3>
Parametri Posizionali
</titolo_3>
<testo_normale>
Un punto interrogativo (?) denota un parametro posizionale, passato ad ${sbk}execute()${ebk} come membro di una tupla.
</testo_normale>
<py_code>
import sqlite3
import sys

db_filename = 'todo.db'
project_name = sys.argv[1]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    query = "select id, priorita, dettagli, stato, scadenza from compito where progetto = ?"

    cursor.execute(query, (project_name,))

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-20s [%-8s] (%s)' % (task_id, priority, details, status, deadline)
</py_code>
<testo_normale>
Il parametro da riga di comando viene passato in sicurezza all'interrogazione come parametro posizionale, quindi non vi &egrave; possibilit&agrave; che dati malformati possano intaccare il database.
</testo_normale>
<py_output>
$ python sqlite3_argument_positional.py pymotw-it

 1 {1} descrivere select    [fatto    ] (2010-10-03)
 2 {1} descrivere random    [in attesa] (2010-10-10)
 3 {1} descrivere sqlite3   [attivo   ] (2010-10-17)
</py_output>
<titolo_3>
Parametri Nominali
</titolo_3>
<testo_normale>
Si usano i parametri nominali quando l'interrogazione &egrave; pi&ugrave; complessa, ed &egrave; composta da molti parametri, oppure dove alcuni parametri sono ripetuti diverse volte all'interno dell'interrogazione. I parametri nominali sono prefissati dal simbolo dei due punti (:), tipo ${sev}:nome_parametro${eev}.
</testo_normale>
<py_code>
import sqlite3
import sys

db_filename = 'todo.db'
project_name = sys.argv[1]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    query = """select id, priorita, dettagli, stato, scadenza from compito
            where progetto = :nome_progetto
            order by scadenza, priorita
            """

    cursor.execute(query, {'nome_progetto':project_name})

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print '%2d {%d} %-25s [%-8s] (%s)' % (task_id, priority, details, status, deadline)
</py_code>
<testo_normale>
Non occorre che i parametri posizionali o nominali vengano racchiusi tra virgolette o fatti precedere da sequenze di escape, visto che godono di un trattamento speciale da parte dell'analizzatore dell'interrogazione.
</testo_normale>
<py_output>
$ python sqlite3_argument_nominal.py pymotw-it

 1 {1} descrivere select         [fatto    ] (2010-10-03)
 2 {1} descrivere random         [in attesa] (2010-10-10)
 3 {1} descrivere sqlite3        [attivo   ] (2010-10-17)
</py_output>
<testo_normale>
I parametri di interrogazione possono essere usati con le istruzioni ${sev}select${eev}, ${sev}insert${eev} ed ${sev}update${eev}. Essi possono comparire in qualsiasi parte dell'interrogazione fintanto che il valore letterale &egrave; consentito.
</testo_normale>
<py_code>
import sqlite3
import sys

db_filename = 'todo.db'
id = int(sys.argv[1])
status = sys.argv[2]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()
    query = "update compito set stato = :stato where id = :id"
    cursor.execute(query, {'stato':status, 'id':id})
</py_code>
<testo_normale>
Questa istruzione ${sev}update${eev} usa due parametri nominali. Il valore ${sev}id${eev} viene usato per cercare la giusta riga da modificare, mentre il valore ${sev}stato${eev} viene scritto nella tabella.
</testo_normale>
<py_output>
$ python sqlite3_argument_update.py 2 done
$ python sqlite3_argument_named.py pymotw-it

 1 {1} descrivere select         [fatto   ] (2010-10-03)
 2 {1} descrivere random         [fatto   ] (2010-10-10)
 3 {1} descrivere sqlite3        [attivo  ] (2010-10-17)
</py_output>

<titolo_2>
Caricamento Massivo
</titolo_2>
<testo_normale>
Per applicare la stessa istruzione SQL ad un gran numero di dati si usa ${sbk}executemany()${ebk}. Questo metodo &egrave; utile per caricare i dati, visto che si evita di iterare attraverso gli input in Python e si lascia che sia la libreria sottostante ad occuparsi dell'ottimizzazione delle iterazioni. Questo programma di esempio legge una lista di compiti da un file in formato .csv (valori separati da virgola) usando il modulo <a href='csv.html'>csv</a> e li carica nel database.
</testo_normale>
<py_code>
import csv
import sqlite3
import sys

db_filename = 'todo.db'
data_filename = sys.argv[1]

SQL = """insert into compito (dettagli, priorita, stato, scadenza, progetto)
         values (:dettagli, :priorita, 'attivo', :scadenza, :progetto)
      """

with open(data_filename, 'rt') as csv_file:
    csv_reader = csv.DictReader(csv_file)
    
    with sqlite3.connect(db_filename) as conn:
        cursor = conn.cursor()
        cursor.executemany(SQL, csv_reader)
</py_code>
<testo_normale>
I dati di esempio contenuti nel file ${sev}tasks.csv${eev} sono:
</testo_normale>
<py_output>
$ cat tasks.csv 

scadenza,progetto,priorita,dettagli
2010-10-02,pymotw-it,2,"finire la revisione di markup"
2010-10-03,pymotw-it,2,"revisione del capitolo intros"
2010-10-03,pymotw-it,1,"subtitle"
</py_output>
<testo_normale>
L'esecuzione del programma produce:
</testo_normale>
<py_output>
$ python sqlite3_load_csv.py tasks.csv 
$ python sqlite3_argument_nominal.py pymotw-it

 4 {2} finire la revisione di markup [attivo   ] (2010-10-02)
 1 {1} descrivere select             [fatto    ] (2010-10-03)
 6 {1} subtitle                      [attivo   ] (2010-10-03)
 5 {2} revisione del capitolo intros [attivo   ] (2010-10-03)
 2 {1} descrivere random             [in attesa] (2010-10-10)
 3 {1} descrivere sqlite3            [attivo   ] (2010-10-17)
</py_output>
<titolo_2>
Tipi di Colonna
</titolo_2>
<testo_normale>
SQLite ha supporto nativo per colonne di interi, valori a virgola mobile, e colonne di testo. Dati di questi tipi sono convertiti automaticamente da <strong>sqlite3</strong> dalla rappresentazione di Python in un valore che possa essere conservato nel database, e viceversa, quando necessario. I valori interi sono caricati dal database in variabili ${sev}int${eev} oppure ${sev}long${eev}, a seconda della dimensione del valore. Il testo viene salvato e recuperato come ${sev}unicode${eev}, a meno che non sia stato modificato il valore ${sev}text_factory${eev} della <strong>connessione</strong>.
</testo_normale>
<testo_normale>
Sebbene SQLite supporti solo pochi tipi di dato internamente, <strong>sqlite3</strong> comprende delle facilitazioni per definire tipi personalizzati per consentire all'applicazione Python di conservare in una colonna un qualsiasi tipo di dato. La conversione tra tipi oltre a quelli supportati in modo predefinito sono abilitati nella connessione al database usando il flag ${sev}detect_types${eev}. Si usa ${sev}PARSE_DECLTYPES${eev} se la colonna &egrave; stata dichiarata usando il tipo desiderato quando la tabella &egrave; stata definita.
</testo_normale>
<py_code>
import sqlite3
import sys

db_filename = 'todo.db'

sql = "select id, dettagli, scadenza from compito"

def show_deadline(conn):
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute(sql)
    row = cursor.fetchone()
    for col in ['id', 'dettagli', 'scadenza']:
        print '  colunna:', col
        print '    valore :', row[col]
        print '    tipo   :', type(row[col])
    return

print 'Senza identificazione del tipo:'

with sqlite3.connect(db_filename) as conn:
    show_deadline(conn)

print '\nCon identificazione del tipo:'

with sqlite3.connect(db_filename, detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    show_deadline(conn)
</py_code>
<testo_normale>
<strong>sqlite3</strong> fornisce del convertitori per colonne data e timestamp, usando ${sbk}date${ebk} e ${sbk}datetime${ebk} dal modulo <a href='datetime.html'>datetime</a> per rappresentare i valori in Python. Entrambi i convertitori relativi alle date sono abilitati automaticamente quando viene attivata l'identificazione del tipo.
</testo_normale>
<py_output>
$ python sqlite3_date_types.py 
Senza identificazione del tipo:
  colunna: id
    valore : 1
    tipo   : <type 'int'>
  colunna: dettagli
    valore : descrivere select
    tipo   : <type 'unicode'>
  colunna: scadenza
    valore : 2010-10-03
    tipo   : <type 'unicode'>

Con identificazione del tipo:
  colunna: id
    valore : 1
    tipo   : <type 'int'>
  colunna: dettagli
    valore : descrivere select
    tipo   : <type 'unicode'>
  colunna: scadenza
    valore : 2010-10-03
    tipo   : <type 'datetime.date'>
</py_output>
<titolo_2>
Tipi Personalizzati
</titolo_2>
<testo_normale>
Occorre registrare due funzioni per definire un nuovo tipo. <em>adapter</em> riceve l'oggetto Python come input e lo restituisce come stringa di byte che pu&ograve; essere conservata nel database. <em>converter</em> riceve la stringa dal database e restituisce un oggetto Python. Si usa ${sbk}register_adapter()${ebk} per definire una funzione <em>adapter</em> e ${sbk}register_converter()${ebk} per la funzione <em>converter</em>.
</testo_normale>
<py_code>
import sqlite3
try:
    import cPickle as pickle
except:
    import pickle

db_filename = 'todo.db'

def adapter_func(obj):
    """Converte da in-memoria alla rappresentazione del valore da conservare
    """
    print 'adapter_func(%s)\n' % obj
    return pickle.dumps(obj)

def converter_func(data):
    """Converte da valore conservato a rappresentazione in-memoria.
    """
    print 'converter_func(%r)\n' % data
    return pickle.loads(data)


class MyObj(object):
    def __init__(self, arg):
        self.arg = arg
    def __str__(self):
        return 'MyObj(%r)' % self.arg

# Registra le funczioni per la manipolazione del tipo.
sqlite3.register_adapter(MyObj, adapter_func)
sqlite3.register_converter("MyObj", converter_func)

# Crea alcuni oggetti da salvare.  Usa una lista di tuple in modo da poter
# passare questa sequanza direttamente a executemany().
to_save = [ (MyObj("questo e' il valore da salvare"),),
            (MyObj(42),),
            ]

with sqlite3.connect(db_filename, detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    # Crea una tabella con una colonna di tipo MyObj"
    conn.execute("""
    create table if not exists obj (
        id    integer primary key autoincrement not null,
        data  MyObj
    )
    """)
    cursor = conn.cursor()

    # Inserisce gli oggetti nel  database
    cursor.executemany("insert into obj (data) values (?)", to_save)

    # Interroga il database richiedendo gli oggetti appena salvati
    cursor.execute("select id, data from obj")
    for obj_id, obj in cursor.fetchall():
        print 'Recuperato', obj_id, obj, type(obj)
        print
</py_code>
<testo_normale>
Questo esempio usa <a href='pickle.html'>pickle</a> per salvare un oggetto verso una stringa che possa essere conservata nel database. Questa tecnica &egrave; utile per conservare oggetti arbitrari, ma non consente una interrogazione basata sugli attributi dell'oggetto. Un vero mappatore relazionale di oggetti tipo SQLAlchemy che conserva i valori di attributo nelle sue proprie colonne sarebbe molto pi&ugrave; utile per grandi quantit&agrave; di dati.
</testo_normale>
<py_output>
$ python sqlite3_custom_type.py 

adapter_func(MyObj("questo e' il valore da salvare"))

adapter_func(MyObj(42))

converter_func('ccopy_reg\n_reconstructor\np1\n(c__main__\nMyObj\np2\nc__builtin__\nobject\np3\nNtRp4\n(dp5\nS\'arg\'\np6\nS"questo e\' il valore da salvare"\np7\nsb.')

converter_func("ccopy_reg\n_reconstructor\np1\n(c__main__\nMyObj\np2\nc__builtin__\nobject\np3\nNtRp4\n(dp5\nS'arg'\np6\nI42\nsb.")

Recuperato 1 MyObj("questo e' il valore da salvare") <class '__main__.MyObj'>

Recuperato 2 MyObj(42) <class '__main__.MyObj'>
</py_output>
<titolo_2>
Derivare i Tipi dai Nomi delle Colonne
</titolo_2>
<testo_normale>
Ci sono due fonti per le informazioni sul tipo per quanto riguarda i dati per una interrogazione. La dichiarazione originale della tabella pu&ograve; essere usata per identificare il tipo di una colonna reale, come mostrato qui sopra. Uno specificatore di tipo pu&ograve; essere anche incluso nella clausola ${sev}select${eev} dell'interrogazione usando la forma "${sev}nome [tipo]${eev}".
</testo_normale>
<py_code>
import sqlite3
try:
    import cPickle as pickle
except:
    import pickle

db_filename = 'todo.db'

def adapter_func(obj):
    """Converte da in-memoria alla rappresentazione del valore da conservare
    """
    print 'adapter_func(%s)\n' % obj
    return pickle.dumps(obj)

def converter_func(data):
    """Converte da valore conservato a rappresentazione in-memoria.
    """
    print 'converter_func(%r)\n' % data
    return pickle.loads(data)


class MyObj(object):
    def __init__(self, arg):
        self.arg = arg
    def __str__(self):
        return 'MyObj(%r)' % self.arg

# Registra le funczioni per la manipolazione del tipo.
sqlite3.register_adapter(MyObj, adapter_func)
sqlite3.register_converter("MyObj", converter_func)

# Crea alcuni oggetti da salvare.  Usa una lista di tuple in modo da poter
# passare questa sequanza direttamente a executemany().
to_save = [ (MyObj("questo e' il valore da salvare"),),
            (MyObj(42),),
            ]

with sqlite3.connect(db_filename, detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    # Crea una tabella con una colonna di tipo MyObj"
    conn.execute("""
    create table if not exists obj (
        id    integer primary key autoincrement not null,
        data  MyObj
    )
    """)
    cursor = conn.cursor()

    # Inserisce gli oggetti nel  database
    cursor.executemany("insert into obj (data) values (?)", to_save)

    # Interroga il database richiedendo gli oggetti appena salvati
    cursor.execute("select id, data from obj")
    for obj_id, obj in cursor.fetchall():
        print 'Recuperato', obj_id, obj, type(obj)
        print
</py_code>
<testo_normale>
Si usa il flag ${sev}detect_types${eev} con il valore ${sev}PARSE_COLNAMES${eev} quando il tipo &egrave; parte dell'interrogazione invece che della definizione originale della tabella.
</testo_normale>
<py_output>
$ python sqlite3_custom_type_column.py 

adapter_func(MyObj("questo e' il valore da salvare"))

adapter_func(MyObj(42))

converter_func('ccopy_reg\n_reconstructor\np1\n(c__main__\nMyObj\np2\nc__builtin__\nobject\np3\nNtRp4\n(dp5\nS\'arg\'\np6\nS"questo e\' il valore da salvare"\np7\nsb.')

converter_func("ccopy_reg\n_reconstructor\np1\n(c__main__\nMyObj\np2\nc__builtin__\nobject\np3\nNtRp4\n(dp5\nS'arg'\np6\nI42\nsb.")

Recuperato 1 MyObj("questo e' il valore da salvare") <class '__main__.MyObj'>

Recuperato 2 MyObj(42) <class '__main__.MyObj'>
</py_output>
<titolo_2>
Transazioni
</titolo_2>
<testo_normale>
Una delle funzionalit&agrave; chiave dei database relazionali &egrave; l'uso delle <em>transazioni</em> per mantenere uno stato interno consistente. Con le transazioni abilitate, si possono effettuare parecchie modifiche tramite una connessione senza che qualsiasi altro utente ne sia coinvolto, fino a che i risultati sono <em>confermati</em> e definitivamente scritti sul database reale.
</testo_normale>
<titolo_3>
Preservare le Modifiche
</titolo_3>
<testo_normale>
Le modifiche al database, sia tramite istruzioni di ${sev}insert${eev} o ${sev}update${eev} devono essere salvate chiamando esplicitamente ${sbk}commit()${ebk}. Questo requisito fornisce ad una applicazione la possibilit&agrave; di effettuare parecchie modifiche insieme, per poi conservarle <em>atomicamente</em> invece che in modo incrementale, evitando situazioni nelle quali aggiornamenti parziali possano essere visti da client diversi in connessione al database. 
</testo_normale>
<testo_normale>
L'effetto della chiamata di ${sbk}commit()${ebk} pu&ograve; essere visto con un programma che usa parecchie connessioni al database. Una nuova riga viene inserita con la prima connessione, quindi vengono effettuati due tentativi di leggere la riga inserita usando connessioni separate.
</testo_normale>
<py_code>
import sqlite3

db_filename = 'todo.db'

def show_projects(conn):
    cursor = conn.cursor()
    cursor.execute('select nome, descrizione from progetto')
    for name, desc in cursor.fetchall():
        print '  ', name
    return

with sqlite3.connect(db_filename) as conn1:

    print 'Prima delle modifiche:'
    show_projects(conn1)

    # Istruzione Insert in un cursore
    cursor1 = conn1.cursor()
    cursor1.execute("""
    insert into progetto (nome, descrizione, scadenza)
    values ('virtualenvwrapper', 'Estensioni Virtualenv', '2011-01-01')
    """)

    print '\nDopo le modifiche in conn1:'
    show_projects(conn1)

    # Istruzione Select da un'altra connessione, senza prima chiamare commit
    print '\nPrima di commit:'
    with sqlite3.connect(db_filename) as conn2:
        show_projects(conn2)

    # Chiamata di Commit quindi select da un'altra connessione
    conn1.commit()
    print '\nDopo commit:'
    with sqlite3.connect(db_filename) as conn3:
        show_projects(conn3)
</py_code>
<testo_normale>
Quando viene chiamato ${sbk}show_projects()${ebk} prima della chiamata di commit da ${sev}conn1${eev}, i risultati dipendono da quale connessione viene usata. Visto che le modifiche sono state fatte tramite ${sev}conn1${eev}, essa vede i dati modificati. D'altro canto ${sev}conn2${eev} non li vede. Dopo la chiamata di commit, la nuova connessione ${sev}conn3${eev} vede la riga inserita.
</testo_normale>
<py_output>
$ python sqlite3_transaction_commit.py 
Prima delle modifiches:
   pymotw-it

Dopo le modifiche in conn1:
   pymotw-it
   virtualenvwrapper

Prima di commit:
   pymotw-it

Dopo commit:
   pymotw-it
   virtualenvwrapper
</py_output>
<titolo_3>
Scartare le Modifiche
</titolo_3>
<testo_normale>
Le modifiche non ancora confermate possono essere scartate interamente usando ${sbk}rollback()${ebk}. I metodi ${sbk}commit()${ebk} e ${sbk}rollback()${ebk} sono in genere chiamati da parti diverse dello stesso blocco ${sev}tyr:except${eev}, con gli errori che fanno scattare lo scarto delle modifiche.
</testo_normale>
<py_code>
import sqlite3

db_filenome = 'todo.db'

def show_projects(conn):
    cursor = conn.cursor()
    cursor.execute('select nome, descrizione from progetto')
    for nome, desc in cursor.fetchall():
        print '  ', nome
    return

with sqlite3.connect(db_filenome) as conn:

    print 'Prima delle modifiche:'
    show_projects(conn)

    try:

        # Istruzione di cancellazione
        cursor = conn.cursor()
        cursor.execute("delete from progetto where nome = 'virtualenvwrapper'")

        # Mostra i risultati
        print '\Dopo la cancellazione:'
        show_projects(conn)

        # Finge che l'esecuzione abbia causato un errore
        raise RuntimeError('errore simulato')

    except Exception, err:
        # Scarta le  modifiche
        print 'ERRORE:', err
        conn.rollback()
        
    else:
        # Salva le modifiche
        conn.commit()

    # Mostra i risultati
    print '\nDopo la chiamata di rollback:'
    show_progettos(conn)
</py_code>
<testo_normale>
Dopo la chiamata di ${sbk}rollback()${ebk} le modifiche al database non esistono pi&ugrave;.
</testo_normale>
<py_output>
$ python sqlite3_transaction_rollback.py 

Prima delle modifiche:
   pymotw-it
   virtualenvwrapper
\Dopo la cancellazione:
   pymotw-it
ERRORE: errore simulato

Dopo la chiamata di rollback:
   pymotw-it
   virtualenvwrapper
</py_output>
<titolo_3>
Livelli di Isolamento
</titolo_3>
<testo_normale>
<strong>sqlite3</strong> supporta tre modalit&agrave; di bloccaggio, chiamate <em>livelli di isolamento</em> che controllano i bloccaggi usati per prevenire modifiche incompatibili tra le connessioni. Il livello di isolamento viene impostato passando una stringa al parametro <em>isolation_level</em> quando viene aperta una connessione, in modo che diverse connessioni possano usare diversi valori.
</testo_normale>
<testo_normale>
Questo programma dimostra l'effetto di diversi livelli di isolamento sull'ordine di eventi nei thread usando connessioni separate allo stesso database. Vengono creati quattro thread. Due scrivono le modifiche al database aggiornando righe esistenti. Gli altri tentano di leggere tutte le righe della tabella ${sev}compito${eev}.
</testo_normale>
<py_code>
import logging
import sqlite3
import sys
import threading
import time

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s (%(threadName)-10s) %(message)s',
                    )

db_filename = 'todo.db'
isolation_level = sys.argv[1]

def writer():
    my_name = threading.currentThread().name
    logging.debug('in connessione')
    with sqlite3.connect(db_filename, isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        logging.debug('connesso')
        cursor.execute('update compito set priorita = priorita + 1')
        logging.debug('modifiche effettuate')
        logging.debug('in attesa di sincronizzare')
        ready.wait() # sincronizza
        logging.debug('IN PAUSA')
        time.sleep(1)
        conn.commit()
        logging.debug('MODIFICHE EFFETTUATE')
    return

def reader():
    my_name = threading.currentThread().name
    with sqlite3.connect(db_filename, isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        logging.debug('in attesa di sincronizzare')
        ready.wait() # sincronizza
        logging.debug('attendo oltre')
        cursor.execute('select * from compito')
        logging.debug('SELECT ESEGUITO')
        results = cursor.fetchall()
        logging.debug('risultati recuperati')
    return

if __name__ == '__main__':
    ready = threading.Event()

    threads = [
        threading.Thread(name='Lettore 1', target=reader),
        threading.Thread(name='Lettore 2', target=reader),
        threading.Thread(name='Scrittore 1', target=writer),
        threading.Thread(name='Scrittore 2', target=writer),
        ]
    
    [ t.start() for t in threads ]
    
    time.sleep(1)
    logging.debug('impostazioni pronte')
    ready.set()

    [ t.join() for t in threads ]
</py_code>
<testo_normale>
I thread sono sincronizzati usando ${sev}Event${eev} dal modulo threading. La funzione ${sbk}writer()${ebk} connette ed effettua le modifiche al database, ma non chiama commit prima che scatti l'evento. La funzione ${sbk}reader()${ebk} si connette, quindi attende prima di interrogare il database fino a quando l'evento di sincronizzazione non si verifica.
</testo_normale>

<titolo_3>
Isolamento Differito
</titolo_3>
<testo_normale>
Il livello di isolamento predefinito &egrave; ${sev}DEFERRED${eev} (differito). L'uso di questa modalit&agrave; blocca il database, ma solo dopo che una modifica &egrave; iniziata. Tutti gli esempi precedenti usano la modalit&agrave; differita.
</testo_normale>
<py_output>
$ python sqlite3_isolation_levels.py DEFERRED

2011-02-13 09:56:18,943 (Lettore 1 ) in attesa di sincronizzare
2011-02-13 09:56:18,943 (Lettore 2 ) in attesa di sincronizzare
2011-02-13 09:56:18,943 (Scrittore 1) in connessione
2011-02-13 09:56:18,943 (Scrittore 2) in connessione
2011-02-13 09:56:18,944 (Scrittore 1) connesso
2011-02-13 09:56:18,944 (Scrittore 2) connesso
2011-02-13 09:56:18,966 (Scrittore 2) modifiche effettuate
2011-02-13 09:56:18,966 (Scrittore 2) in attesa di sincronizzare
2011-02-13 09:56:19,944 (MainThread) impostazioni pronte
2011-02-13 09:56:19,945 (Scrittore 2) IN PAUSA
2011-02-13 09:56:19,945 (Lettore 1 ) attendo oltre
2011-02-13 09:56:19,945 (Lettore 2 ) attendo oltre
2011-02-13 09:56:19,946 (Lettore 2 ) SELECT ESEGUITO
2011-02-13 09:56:19,946 (Lettore 2 ) risultati recuperati
2011-02-13 09:56:19,947 (Lettore 1 ) SELECT ESEGUITO
2011-02-13 09:56:19,947 (Lettore 1 ) risultati recuperati
2011-02-13 09:56:20,999 (Scrittore 2) MODIFICHE EFFETTUATE
2011-02-13 09:56:21,090 (Scrittore 1) modifiche effettuate
2011-02-13 09:56:21,090 (Scrittore 1) in attesa di sincronizzare
2011-02-13 09:56:21,090 (Scrittore 1) IN PAUSA
2011-02-13 09:56:22,111 (Scrittore 1) MODIFICHE EFFETTUATE
</py_output>
<titolo_3>
Isolamento Immediato
</titolo_3>
<testo_normale>
La modalit&agrave; di isolamento immediato blocca il database non appena viene iniziata una modifica e previene gli altri cursori dall'effettuare modifiche fino a che viene chiamato commit sulla transazione. E' adatto per un database che debba effettuare scritture complesse ma con pi&ugrave; accessi in lettura che in scrittura, visto che gli accessi in lettura non sono bloccati mentre la transazione &egrave; in esecuzione.
</testo_normale>
<py_output>
$ python sqlite3_isolation_levels.py IMMEDIATE

2011-02-13 10:09:17,984 (Lettore 1 ) in attesa di sincronizzare
2011-02-13 10:09:17,984 (Scrittore 1) in connessione
2011-02-13 10:09:17,984 (Scrittore 1) connesso
2011-02-13 10:09:17,985 (Scrittore 2) in connessione
2011-02-13 10:09:17,985 (Scrittore 2) connesso
2011-02-13 10:09:17,986 (Lettore 2 ) in attesa di sincronizzare
2011-02-13 10:09:17,988 (Scrittore 1) modifiche effettuate
2011-02-13 10:09:17,988 (Scrittore 1) in attesa di sincronizzare
2011-02-13 10:09:18,986 (MainThread) impostazioni pronte
2011-02-13 10:09:18,986 (Lettore 1 ) attendo oltre
2011-02-13 10:09:18,987 (Lettore 1 ) SELECT ESEGUITO
2011-02-13 10:09:18,987 (Lettore 1 ) risultati recuperati
2011-02-13 10:09:18,987 (Scrittore 1) IN PAUSA
2011-02-13 10:09:18,988 (Lettore 2 ) attendo oltre
2011-02-13 10:09:18,988 (Lettore 2 ) SELECT ESEGUITO
2011-02-13 10:09:18,988 (Lettore 2 ) risultati recuperati
2011-02-13 10:09:20,007 (Scrittore 1) MODIFICHE EFFETTUATE
2011-02-13 10:09:20,019 (Scrittore 2) modifiche effettuate
2011-02-13 10:09:20,019 (Scrittore 2) in attesa di sincronizzare
2011-02-13 10:09:20,019 (Scrittore 2) IN PAUSA
2011-02-13 10:09:21,606 (Scrittore 2) MODIFICHE EFFETTUATE
</py_output>
<titolo_3>
Isolamento Esclusivo
</titolo_3>
<testo_normale>
La modalit&agrave; di isolamento esclusiva blocca il database a tutti gli accessi in lettura e scrittura. Il suo uso &egrave; limitato a situazioni dove le prestazioni sul database siano importanti, visto che ogni connessione esclusiva blocca tutti gli altri utenti.
</testo_normale>
<py_output>
$ python sqlite3_isolation_levels.py EXCLUSIVE

2011-02-13 10:11:48,784 (Lettore 2 ) in attesa di sincronizzare
2011-02-13 10:11:48,784 (Lettore 1 ) in attesa di sincronizzare
2011-02-13 10:11:48,784 (Scrittore 1) in connessione
2011-02-13 10:11:48,785 (Scrittore 1) connesso
2011-02-13 10:11:48,786 (Scrittore 1) modifiche effettuate
2011-02-13 10:11:48,786 (Scrittore 1) in attesa di sincronizzare
2011-02-13 10:11:48,787 (Scrittore 2) in connessione
2011-02-13 10:11:48,787 (Scrittore 2) connesso
2011-02-13 10:11:49,788 (MainThread) impostazioni pronte
2011-02-13 10:11:49,788 (Lettore 1 ) attendo oltre
2011-02-13 10:11:49,788 (Scrittore 1) IN PAUSA
2011-02-13 10:11:49,788 (Lettore 2 ) attendo oltre
2011-02-13 10:11:50,807 (Scrittore 1) MODIFICHE EFFETTUATE
2011-02-13 10:11:50,818 (Scrittore 2) modifiche effettuate
2011-02-13 10:11:50,818 (Scrittore 2) in attesa di sincronizzare
2011-02-13 10:11:50,818 (Scrittore 2) IN PAUSA
2011-02-13 10:11:51,839 (Scrittore 2) MODIFICHE EFFETTUATE
2011-02-13 10:11:51,919 (Lettore 1 ) SELECT ESEGUITO
2011-02-13 10:11:51,919 (Lettore 2 ) SELECT ESEGUITO
2011-02-13 10:11:51,920 (Lettore 1 ) risultati recuperati
2011-02-13 10:11:51,920 (Lettore 2 ) risultati recuperati
</py_output>
<testo_normale>
Visto che la prima connessione in scrittura ha iniziato a compiere modifiche, le connessioni in lettura e la seconda connessione in scrittura sono bloccate fino alla chiamata di commit della prima. La chiamata di ${sbk}sleep()${ebk} induce un ritardo artificiale nel thread di scrittura per evidenziare il fatto che le altre connessioni sono bloccate.
</testo_normale>
<titolo_3>
Modalit&agrave; Autocommit
</titolo_3>
<testo_normale>
Il parametro <em>isolation_level</em> per una connessione pu&agrave; anche essere impostato a ${sev}None${eev} per abilitare la modalit&agrave; di conferma automatica (autocommit). Con autocommit abilitato, ogni chiamata di ${sbk}execute()${ebk} viene confermata immediatamente dopo che l'istruzione finisce. La modalit&agrave; autocommit &egrave; adatta per brevi transazioni, tipo l'inserimento di una piccola mole di dati in una singola tabella. Il database viene bloccato per il minor tempo possibile, in modo che le possibilit&agrave; di conflitto tra i thread siano minori.
</testo_normale>
<py_code>
import logging
import sqlite3
import sys
import threading
import time

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s (%(threadName)-10s) %(message)s',
                    )

db_filename = 'todo.db'
isolation_level = None # autocommit mode

def writer():
    my_name = threading.currentThread().name
    logging.debug('in connessione')
    with sqlite3.connect(db_filename, isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        logging.debug('connesso')
        cursor.execute('update compito set priorita = priorita + 1')
        logging.debug('modifiche effettuate')
        logging.debug('in attesa di sincronizzare')
        ready.wait() # sincronizza
        logging.debug('IN PAUSA')
        logging.debug('MODIFICHE EFFETTUATE')
        time.sleep(1)
    return

def reader():
    my_name = threading.currentThread().name
    with sqlite3.connect(db_filename, isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        logging.debug('in attesa di sincronizzare')
        ready.wait() # sincronizza
        logging.debug('attendo oltre')
        cursor.execute('select * from compito')
        logging.debug('SELECT ESEGUITO')
        results = cursor.fetchall()
        logging.debug('risultati recuperati')
    return

if __name__ == '__main__':
    ready = threading.Event()

    threads = [
        threading.Thread(name='Lettore 1', target=reader),
        threading.Thread(name='Lettore 2', target=reader),
        threading.Thread(name='Scrittore 1', target=writer),
        threading.Thread(name='Scrittore 2', target=writer),
        ]
    
    [ t.start() for t in threads ]
    
    time.sleep(1)
    logging.debug('impostazioni pronte')
    ready.set()

    [ t.join() for t in threads ]
</py_code>
<testo_normale>
La chiamata esplicita a ${sbk}commit()${ebk} &egrave; stata rimossa, ma per tutto il resto ${sev}sqlite3_autocommit.py${eev} &egrave; uguale a ${sev}sqlite3_isolation_levels.py${eev}. L'output &egrave; diverso, comunque, visto che entrambi i thread in scrittura finiscono il proprio lavoro prima che i thread in lettura inizino le interrogazioni.
</testo_normale>
<py_output>
$ python sqlite3_autocommit.py 

2011-02-13 13:15:31,097 (Scrittore 1) in connessione
2011-02-13 13:15:31,097 (Scrittore 2) in connessione
2011-02-13 13:15:31,120 (Lettore 2 ) in attesa di sincronizzare
2011-02-13 13:15:31,120 (Scrittore 1) connesso
2011-02-13 13:15:31,127 (Scrittore 2) connesso
2011-02-13 13:15:31,127 (Lettore 1 ) in attesa di sincronizzare
2011-02-13 13:15:31,247 (Scrittore 1) modifiche effettuate
2011-02-13 13:15:31,248 (Scrittore 1) in attesa di sincronizzare
2011-02-13 13:15:31,343 (Scrittore 2) modifiche effettuate
2011-02-13 13:15:31,343 (Scrittore 2) in attesa di sincronizzare
2011-02-13 13:15:32,098 (MainThread) impostazioni pronte
2011-02-13 13:15:32,099 (Scrittore 1) IN PAUSA
2011-02-13 13:15:32,099 (Scrittore 1) MODIFICHE EFFETTUATE
2011-02-13 13:15:32,099 (Scrittore 2) IN PAUSA
2011-02-13 13:15:32,099 (Scrittore 2) MODIFICHE EFFETTUATE
2011-02-13 13:15:32,099 (Lettore 1 ) attendo oltre
2011-02-13 13:15:32,100 (Lettore 2 ) attendo oltre
2011-02-13 13:15:32,101 (Lettore 2 ) SELECT ESEGUITO
2011-02-13 13:15:32,101 (Lettore 1 ) SELECT ESEGUITO
2011-02-13 13:15:32,101 (Lettore 1 ) risultati recuperati
2011-02-13 13:15:32,101 (Lettore 2 ) risultati recuperati
</py_output>
<titolo_2>
Comportamenti Definiti dall'Utente
</titolo_2>
<testo_normale>
<strong>sqlite3</strong> supporta diversi meccanismi di estensione, con supporto per estendere la funzionalit&agrave; del database con funzioni e classi implementate in Python.
</testo_normale>
<titolo_3>
Usare Funzioni Python in SQL
</titolo_3>
<testo_normale>
La sintassi SQL supporta la chiamata a funzioni durante le interrogazioni, sia nell'elenco di colonne che nella clausola ${sev}where${eev} dell'istruzione ${sev}select${eev}. Questa funzionalit&agrave; rende possibile l'elaborazione dei dati prima di essere restituiti dall'interrogazione, e pu&ograve; essere usata per convertire tra diversi formati, eseguire calcoli che sarebbero mal costruiti in puro linguaggio SQL, e riusare il codice dell'applicazione.
</testo_normale>
<py_code>
import sqlite3

db_filename = 'todo.db'

def encrypt(s):
    print 'Codifica %r' % s
    return s.encode('rot-13')

def decrypt(s):
    print 'Decodifica %r' % s
    return s.encode('rot-13')


with sqlite3.connect(db_filename) as conn:
    conn.create_function('encrypt', 1, encrypt)
    conn.create_function('decrypt', 1, decrypt)
    cursor = conn.cursor()

    # Raw values
    print 'Valori originali:'
    query = "select id, dettagli from compito"
    cursor.execute(query)
    for row in cursor.fetchall():
        print row

    print '\nCodifica...'
    query = "update compito set dettagli = encrypt(dettagli)"
    cursor.execute(query)
    
    print '\nValori codificati grezzi:'
    query = "select id, dettagli from compito"
    cursor.execute(query)
    for row in cursor.fetchall():
        print row
    
    print "\nDecodifica nell'interrogazione ..."
    query = "select id, decrypt(dettagli) from compito"
    cursor.execute(query)
    for row in cursor.fetchall():
        print row
</py_code>
<testo_normale>
Le funzioni sono esposte usando il metodo ${sbk}create_function()${ebk} della <strong>Connessione</strong>. I parametri sono il nome della funzione (come dovrebbe essere usata dall'interno di SQL), il numero di parametri che riceve la funzione e la funzione Python da esporre.
</testo_normale>
<py_output>
$ python sqlite3_create_function.py 

Valori originali:
(1, u'descrivere select')
(2, u'descrivere random')
(3, u'descrivere sqlite3')
(4, u'finire la revisione di markup')
(5, u'revisione del capitolo intros')
(6, u'subtitle')

Codifica...
Codifica u'descrivere select'
Codifica u'descrivere random'
Codifica u'descrivere sqlite3'
Codifica u'finire la revisione di markup'
Codifica u'revisione del capitolo intros'
Codifica u'subtitle'

Valori codificati grezzi:
(1, u'qrfpevirer fryrpg')
(2, u'qrfpevirer enaqbz')
(3, u'qrfpevirer fdyvgr3')
(4, u'svaver yn erivfvbar qv znexhc')
(5, u'erivfvbar qry pncvgbyb vagebf')
(6, u'fhogvgyr')

Decodifica nell'interrogazione ...
Decodifica u'qrfpevirer fryrpg'
Decodifica u'qrfpevirer enaqbz'
Decodifica u'qrfpevirer fdyvgr3'
Decodifica u'svaver yn erivfvbar qv znexhc'
Decodifica u'erivfvbar qry pncvgbyb vagebf'
Decodifica u'fhogvgyr'
(1, u'descrivere select')
(2, u'descrivere random')
(3, u'descrivere sqlite3')
(4, u'finire la revisione di markup')
(5, u'revisione del capitolo intros')
(6, u'subtitle')
</py_output>
<titolo_3>
Aggregazione Personalizzata
</titolo_3>
<testo_normale>
Una funzione di aggregazione raccoglie molte parti di dati individuali e li somma in un qualche modo. Esempi di funzioni di aggregazione built-in sono ${sev}avg()${eev} (media), ${sev}min()${eev}, ${sev}max()${eev} e ${sev}count()${eev}.
</testo_normale>
<testo_normale>
L'API per gli aggregatori usati da <strong>sqlite3</strong> &egrave; definita nei termini di una classe con due metodi. Il metodo ${sbk}step()${ebk} viene chiamato una volta per ogni valore di dati mentre l'interrogazione viene elaborata. Il metodo ${sbk}finalize()${ebk} viene chiamato una volta alla fine dell'interogazione e dovrebbre restituire il valore aggregato. Questo esempio implementa un aggregatore che ottiene il valore che appare pi&ugrave; frequentemente nell'input.
</testo_normale>
<py_code>
import sqlite3
import collections

db_filename = 'todo.db'

class Mode(object):
    def __init__(self):
        self.counter = collections.Counter()  # Counter è disponibile dalla versione 2.7 
    def step(self, value):
        print 'step(%r)' % value
        self.counter[value] += 1
    def finalize(self):
        result, count = self.counter.most_common(1)[0]
        print 'finalize() -> %r (%d volte)' % (result, count)
        return result

with sqlite3.connect(db_filename) as conn:

    conn.create_aggregate('mode', 1, Mode)
    
    cursor = conn.cursor()
    cursor.execute("select mode(scadenza) from compito where progetto = 'pymotw-it'")
    row = cursor.fetchone()
    print "Il mode(scadenza) &egrave;:", row[0]
</py_code>
<testo_normale>
La classe aggregatore viene registrata con il metodo ${sbk}create_aggregate()${ebk} della <strong>Connessione</strong>. I parametri sono il nome della funzione (come dovrebbe essere usata all'interno di SQL), il numero di parametri che riceve il metodo ${sbk}step()${ebk} e la classe da usare.
</testo_normale>
<py_output>
$ python sqlite3_create_aggregate.py

step(u'2010-10-03')
step(u'2010-10-10')
step(u'2010-10-17')
step(u'2010-10-02')
step(u'2010-10-03')
step(u'2010-10-03')
finalize() -> u'2010-10-03' (3 volte)
il mode(scadenza) &egrave;: 2010-10-03
</py_output>
<titolo_3>
Ordinamento Personalizzato
</titolo_3>
<testo_normale>
Si definisce <em>collation</em>  una funzione di confronto usata nella sezione ${sev}order by${eev} di una interrogazione SQL. Le funzioni di confronto personalizzate possono essere usate per comparare tipi di dato che altrimenti non potrebbero essere ordinati internamente da SQLite. Ad esempio una collation personalizzata potebbe essere necessaria per ordinare gli oggetti pickle salvati con lo script ${sev}sqlite3_custom_type.py${eev} qui sopra.
</testo_normale>
<py_code>
import sqlite3
try:
    import cPickle as pickle
except:
    import pickle

db_filename = 'todo.db'

def adapter_func(obj):
    return pickle.dumps(obj)

def converter_func(data):
    return pickle.loads(data)

class MyObj(object):
    def __init__(self, arg):
        self.arg = arg
    def __str__(self):
        return 'MyObj(%r)' % self.arg
    def __cmp__(self, other):
        return cmp(self.arg, other.arg)

# Registra le funzioni per manipoloare il tipo
sqlite3.register_adapter(MyObj, adapter_func)
sqlite3.register_converter("MyObj", converter_func)

def collation_func(a, b):
    a_obj = converter_func(a)
    b_obj = converter_func(b)
    print 'collation_func(%s, %s)' % (a_obj, b_obj)
    return cmp(a_obj, b_obj)

with sqlite3.connect(db_filename, detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    # Definisce la collation
    conn.create_collation('unpickle', collation_func)

    # Pulisce la tabella ed inserisce i nuovi valori
    conn.execute('delete from obj')
    conn.executemany('insert into obj (data) values (?)',
                     [(MyObj(x),) for x in xrange(5, 0, -1)],
                     )

    # Interroga il database per ottenere gli oggetti appena salvati
    print '\nInterrogazione in corso:'
    cursor = conn.cursor()
    cursor.execute("select id, data from obj order by data collate unpickle")
    for obj_id, obj in cursor.fetchall():
        print obj_id, obj
        print
</py_code>
<testo_normale>
I parametri della funzione collation sono stringhe di byte, in modo che possano essere estratti dal pickle e convertiti in istanze di ${sev}MyObj${eev} prima che il confronto sia eseguito.
</testo_normale>
<py_output>
$ python sqlite3_create_collation.py 

Interrogazione in corso:
collation_func(MyObj(5), MyObj(4))
collation_func(MyObj(4), MyObj(3))
collation_func(MyObj(4), MyObj(2))
collation_func(MyObj(3), MyObj(2))
collation_func(MyObj(3), MyObj(1))
collation_func(MyObj(2), MyObj(1))
7 MyObj(1)

6 MyObj(2)

5 MyObj(3)

4 MyObj(4)

3 MyObj(5)
</py_output>
<titolo_2>
Limitare l'accesso ai Dati
</titolo_2>
<testo_normale>
Sebbene SQLite non abbia i controlli per l'accesso utente presenti in altri, pi&ugrave; grandi database relazionali, ha comunque un meccanismo per limitare l'accesso alle colonne. Ogni connessione pu&ograve; installare una <i>funzione di autorizzazione</i> per consentire o negare l'accesso a colonne in fase di esecuzione in base ad un qualsivoglia criterio. La funzione di autorizzazione viene chiamata durante l'elaborazione delle istruzioni SQL e riceve cinque parametri. Il primo &egrave; un codice di azione che indica che tipo di operazione debba essere eseguita (leggere, scrivere, cancellare ecc.). I restanti parametri dipendono dal codice di azione. Per operazioni ${sev}SQLITE_READ${eev} (lettura) i parametri sono il nome della tabella, quello della colonna, il punto nel SQL dove l'accesso deve avvenire (interrogazione principale, trigger ecc.), e <i>None</i>.
</testo_normale>
<py_code>
import sqlite3

db_filename = 'todo.db'

def authorizer_func(action_code, table, column, sql_location, ignore):
    print '\nauthorizer_func(%s, %s, %s, %s, %s)' % \
        (action_code, table, column, sql_location, ignore)

    response = sqlite3.SQLITE_OK # permissiva per default

    if action_code == sqlite3.SQLITE_SELECT:
        print 'richiesta permessi per eseguire una istruzione select'
        response = sqlite3.SQLITE_OK
    
    elif action_code == sqlite3.SQLITE_READ:
        print 'richiesta permessi per alla colonna %s.%s da %s' % \
            (table, column, sql_location)
        if column == 'dettagli':
            print '  si ignorano la colonna dettagli'
            response = sqlite3.SQLITE_IGNORE
        elif column == 'priorita':
            print "  si nega l'accesso alla colonna priorita"
            response = sqlite3.SQLITE_DENY

    return response

with sqlite3.connect(db_filename) as conn:
    conn.row_factory = sqlite3.Row
    conn.set_authorizer(authorizer_func)

    print 'Si usa SQLITE_IGNORE per nascondere un valore di colonna:'
    cursor = conn.cursor()
    cursor.execute("select id, dettagli from compito where progetto = 'pymotw-it'")
    for row in cursor.fetchall():
        print row['id'], row['dettagli']

    print "\nSi usa SQLITE_DENY per negare l'accesso alla colonna:"
    cursor.execute("select id, priorita from compito where progetto = 'pymotw-it'")
    for row in cursor.fetchall():
        print row['id'], row['dettagli']
</py_code>
<testo_normale>
Questo esempio usa ${sbk}SQLITE_IGNORE${ebk} per fare s&igrave; che le stringhe dalla colonna ${sev}compito.dettagli${eev} vengano sostituite con valori null nel risultato dell'interrogazione. Vengono inoltre negati tutti gli accessi alla colonna ${sev}compito.priorita${eev} restituendo ${sbk}SQLITE_DENY${ebk}, che di conseguenza provoca il sollevamento di una eccezione di SQLite.
</testo_normale>
<py_output>
$ python sqlite3_set_authorizer.py 

Si usa SQLITE_IGNORE per nascondere un valore di colonna:

authorizer_func(21, None, None, None, None)
richiesta permessi per eseguire una istruzione select

authorizer_func(20, compito, id, main, None)
richiesta permessi per alla colonna compito.id da main

authorizer_func(20, compito, dettagli, main, None)
richiesta permessi per alla colonna compito.dettagli da main
  si ignorano la colonna dettagli

authorizer_func(20, compito, progetto, main, None)
richiesta permessi per alla colonna compito.progetto da main
1 None
2 None
3 None

Si usa SQLITE_DENY per negare l'accesso alla colonna:

authorizer_func(21, None, None, None, None)
richiesta permessi per eseguire una istruzione select

authorizer_func(20, compito, id, main, None)
richiesta permessi per alla colonna compito.id da main

authorizer_func(20, compito, priorita, main, None)
richiesta permessi per alla colonna compito.priorita da main
  si nega l'accesso alla colonna priorita
Traceback (most recent call last):
  File "sqlite3_set_authorizer.py", line 41, in <module>
    cursor.execute("select id, priorita from compito where progetto = 'pymotw-it'")
sqlite3.DatabaseError: access to compito.priorita is prohibited
</py_output>
<testo_normale>
I possibili codici di azione come costanti sono disponibili in <a href='http://www.doughellmann.com/PyMOTW/sqlite3/index.html#module-sqlite3'>sqlite3</a>, i nomi sono prefissati da ${sev}SQLITE_${eev}. Ciascun tipo di istruzione SQL pu&ograve; essere contrassegnata, cos&igrave; come pu&ograve; essere controllato anche l'accesso alle singole colonne.
</testo_normale>
<titolo_2>
Database In-Memoria
</titolo_2>
<testo_normale>
SQLite supporta la gestione di interi database nella RAM, invece che appoggiarsi ad un file su disco. I database in-memoria sono utili per test automatici, dove il database non deve essere preservato fra un test e l'altro, oppure per fare esperimenti con uno schema od altre funzionalit&agrave; del database. Per aprire un database in-memoria, si usa la stringa ${sev}':memory:'${eev} invece che un nome di file mentre si crea la <strong>Connessione</strong>.
</testo_normale>
<py_code>
import os
import sqlite3


schema_filename = 'todo_schema.sql'

with sqlite3.connect(':memory:') as conn:
    conn.row_factory = sqlite3.Row

    print 'Creazione dello schema'
    with open(schema_filename, 'rt') as f:
        schema = f.read()
    conn.executescript(schema)

    print 'Inserimento dei dati di partenza'
        
    conn.execute("""
    insert into progetto (nome, descrizione, scadenza)
    values ('pymotw-it', 'Il modulo Python della Settimana', '2010-11-01')
    """)
        
    data = [
        ('descrivere select', 'fatto', '2010-10-03', 'pymotw-it'),
        ('descrivere random', 'in attesa', '2010-10-10', 'pymotw-it'),
        ('descrivere sqlite3', 'attivo', '2010-10-17', 'pymotw-it'),
        ]
    
    conn.executemany("""
            insert into compito (dettagli, stato, scadenza, progetto)
            values (?, ?, ?, ?)
            """, data)

    print 'Cerco i compiti ...'
    cursor = conn.cursor()
    cursor.execute("""
    select id, priorita, stato, scadenza, dettagli from compito
    where progetto = 'pymotw-it' order by scadenza
    """)
    for row in cursor.fetchall():
        print '%2d {%d} %-25s [%-8s] (%s)' % (
            row['id'], row['priorita'], row['dettagli'], row['stato'], row['scadenza'],
            )

with sqlite3.connect(':memory:') as conn2:
    print '\nCerco compiti nella seconda connessione...'
    cursor = conn2.cursor()
    cursor.execute("""
    select id, priorita, stato, scadenza, dettagli from compito
    where progetto = 'pymotw-it' order by scadenza
    """)
    for row in cursor.fetchall():
        print '%2d {%d} %-25s [%-8s] (%s)' % (
            row['id'], row['priorita'], row['dettagli'], row['stato'], row['scadenza'],
            )
</py_code>
<testo_normale>
Il secondo tentativo di  interrogazione in questo esempio fallisce con un errore visto che la tabella non esiste. Ogni connessione crea un database separato, quindi le modifiche fatte da un cursore di una connessione non si ripercuotono sulle altre.
</testo_normale>
<py_output>
$ python sqlite3_memory.py 

Creazione dello schema
Inserimento dei dati di partenza
Cerco i compiti ...
 1 {1} descrivere select         [fatto   ] (2010-10-03)
 2 {1} descrivere random         [in attesa] (2010-10-10)
 3 {1} descrivere sqlite3        [attivo  ] (2010-10-17)

Cerco compiti nella seconda connessione...
Traceback (most recent call last):
  File "sqlite3_memory.py", line 53, in <module>
    """)
sqlite3.OperationalError: no such table: compito
</py_output>
<titolo_2>
Esportare il Contenuto di un Database
</titolo_2>
<testo_normale>
Il contenuto di un database in-memoria pu&ograve; essere salvato usando il metodo ${sbk}iterdump()${ebk} della <strong>Connessione</strong>. L'iteratore restituito da ${sbk}iterdump()${ebk} produce una serie di stringhe che assieme costruiscono istruzioni SQL per ricreare lo stato del database.
</testo_normale>
<py_code>
import os
import sqlite3


schema_filename = 'todo_schema.sql'

with sqlite3.connect(':memory:') as conn:
    conn.row_factory = sqlite3.Row

    print 'Creazione dello schema'
    with open(schema_filename, 'rt') as f:
        schema = f.read()
    conn.executescript(schema)

    print 'Inserimento dei dati di partenza'
        
    conn.execute("""
    insert into progetto (nome, descrizione, scadenza)
    values ('pymotw-it', 'Il modulo Python della Settimana', '2010-11-01')
    """)
        
    data = [
        ('descrivere select', 'fatto', '2010-10-03', 'pymotw-it'),
        ('descrivere random', 'in attesa', '2010-10-10', 'pymotw-it'),
        ('descrivere sqlite3', 'attivo', '2010-10-17', 'pymotw-it'),
        ]
    
    conn.executemany("""
            insert into compito (dettagli, stato, scadenza, progetto)
            values (?, ?, ?, ?)
            """, data)

    print 'Scaricamento:'
    for text in conn.iterdump():
        print text
</py_code>
<testo_normale>
${sbk}iterdump()${ebk} pu&ograve; anche essere usato con database salvati su file, ma &egrave; pi&ugrave; utile per preservare un database che altrimenti non potrebbe essere salvato.
</testo_normale>
<py_output>
$ python sqlite3_iterdump.py 
Creazione dello schema
Inserimento dei dati di partenza
Scaricamento:
BEGIN TRANSACTION;
CREATE TABLE progetto (
    nome        text primary key,
    descrizione text,
    scadenza    date
);
INSERT INTO "progetto" VALUES('pymotw-it','Il modulo Python della Settimana','2010-11-01');
CREATE TABLE compito (
    id            integer primary key autoincrement not null,
    priorita      integer default 1,
    dettagli      text,
    stato         text,
    scadenza      date,
    completato_il date,
    progetto      text not null references project(name)
);
INSERT INTO "compito" VALUES(1,1,'descrivere select','fatto','2010-10-03',NULL,'pymotw-it');
INSERT INTO "compito" VALUES(2,1,'descrivere random','in attesa','2010-10-10',NULL,'pymotw-it');
INSERT INTO "compito" VALUES(3,1,'descrivere sqlite3','attivo','2010-10-17',NULL,'pymotw-it');
DELETE FROM sqlite_sequence;
INSERT INTO "sqlite_sequence" VALUES('compito',3);
COMMIT;
</py_output>
<titolo_2>
Threading e Condivisione della Connessione
</titolo_2>
<testo_normale>
Per ragioni storiche che hanno a che fare con vecchie versioni di SQLite, gli oggetti ${sbk}Connection${ebk} non possono essere condivisi fra thread. Ogni thread deve creare la sua propria connessione al database.
</testo_normale>
<py_code>
import sqlite3
import sys
import threading
import time

db_filename = 'todo.db'
isolation_level = None # modalit&agrave; autocommit 

def reader(conn):
    my_name = threading.currentThread().name
    print 'Partenza del thread'
    try:
        cursor = conn.cursor()
        cursor.execute('select * from compiti')
        results = cursor.fetchall()
        print 'risultati recuperati'
    except Exception, err:
        print 'ERRORE:', err
    return

if __name__ == '__main__':

    with sqlite3.connect(db_filename, isolation_level=isolation_level) as conn:
        t = threading.Thread(name='Reader 1', target=reader, args=(conn,))
        t.start()
        t.join()
</py_code>
<testo_normale>
I tentativi di condividere una connessione fra thread generano una eccezione.
</testo_normale>
<py_output>
$ python sqlite3_threading.py 
Partenza del thread
ERRORE: SQLite objects created in a thread can only be used in that same thread.The object was created in thread id -1216571712 and this is thread id -1219478672
</py_output>
<vedi_anche>
http://docs.python.org/library/sqlite3.html|sqlite3|La documentazione della libreria standard per questo modulo
http://www.python.org/dev/peps/pep-0249|PEP 249 - Specifiche DB API 2.0|Una interfaccia standard per moduli che forniscono l'accesso a database relazionali.
http://www.sqlite.org/|SQLite|Il sito ufficiale della libreria SQLite.
shelve.html|shelve|Convervazione chiave-valore per salvare oggetti arbitrari Python
http://sqlalchemy.org/|SQLAlchemy|Un diffuso mappatore relazionale di oggetti che supporta tra i molti altri database relazionali anche SQLite.
</vedi_anche>
</documento_tradotto>
